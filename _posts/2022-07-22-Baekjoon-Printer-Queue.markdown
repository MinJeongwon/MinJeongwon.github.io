---
layout: post
title:  "백준 프린터 큐 문제풀이"
date:   2022-07-22 13:11:36 +0900
categories: coding_test baekjoon
---

문제 제목 : 1966번 [프린터큐]  
문제 난이도 : 하   
문제 유형 : 큐, 구현, 그리디


<br>   

# ✏️ 문제

여러분도 알다시피 여러분의 프린터 기기는 여러분이 인쇄하고자 하는 문서를 인쇄 명령을 받은 ‘순서대로’, 즉 먼저 요청된 것을 먼저 인쇄한다.     
여러 개의 문서가 쌓인다면 **Queue 자료구조에 쌓여서 FIFO - First In First Out - 에 따라 인쇄**가 되게 된다.    
하지만 상근이는 새로운 프린터기 내부 소프트웨어를 개발하였는데, 이 프린터기는 다음과 같은 조건에 따라 인쇄를 하게 된다.   
  1. 현재 Queue의 가장 앞에 있는 문서의 ‘중요도’를 확인한다.
  2. 나머지 문서들 중 현재 문서보다 중요도가 높은 문서가 하나라도 있다면, 이 문서를 인쇄하지 않고 Queue의 가장 뒤에 재배치 한다. 그렇지 않다면 바로 인쇄를 한다.    
 
    예를 들어 Queue에 4개의 문서(A B C D)가 있고, 중요도가 2 1 4 3 라면 C를 인쇄하고, 다음으로 D를 인쇄하고 A, B를 인쇄하게 된다.

여러분이 할 일은, 현재 Queue에 있는 문서의 수와 중요도가 주어졌을 때, 어떤 한 문서가 몇 번째로 인쇄되는지 알아내는 것이다.      
예를 들어 위의 예에서 C문서는 1번째로, A문서는 3번째로 인쇄되게 된다.

- ## 입력   
  첫 줄에 테스트케이스의 수가 주어진다. 각 테스트케이스는 두 줄로 이루어져 있다.      
  테스트케이스의 첫 번째 줄에는 문서의 개수 N(1 ≤ N ≤ 100)과,    
  몇 번째로 인쇄되었는지 궁금한 문서가 현재 Queue에서 몇 번째에 놓여 있는지를 나타내는 정수 M(0 ≤ M < N)이 주어진다.

  이때 맨 왼쪽은 0번째라고 하자.    
  두 번째 줄에는 N개 문서의 중요도가 차례대로 주어진다.     
  
  중요도는 1 이상 9 이하의 정수이고, 중요도가 같은 문서가 여러 개 있을 수도 있다.

- ## 출력
  각 테스트 케이스에 대해 문서가 **몇 번째로 인쇄되는지** 출력한다.    


<br> 

--- 

<br>


## 🔔 아이디어 🔔
* 처음에 입력되는 숫자 만큼의 케이스를 통과하여야 함         
  즉, 5가 입력되면 5개의 queue 케이스에 대해 해결하여야 한다는 의미        
  ➜ loop을 도는 for문을 두어야 함        
* 각 케이스마다 두 줄에 거쳐 입력을 받음.     
  첫 줄은 `요소 개수 n`과 `알고 싶은 요소의 위치 m`    
  두 번째 줄은 각 요소의 중요도 : 숫자가 클수록 중요도가 높음      
  ➜ 케이스별 for문 안에서 n, m을 입력받아야 함     
  ➜ `중요도 리스트`도 만들어야 함   
* 알고 싶은 요소보다 중요도가 큰 숫자는 먼저 인쇄됨             
  ➜ `중요도가 큰 숫자가 리스트의 첫 요소에 위치시킨 후 pop`을 통해 인쇄시키고,      
  인쇄했다는 `연산 횟수를 저장하는 변수`를 두어야 함            
* `맨 첫 요소의 중요도가 가장 높지는 않은 경우 가장 뒤로 보내버리기`   


<br>


## 입력받기
첫 입력으로는 총 입력될 테스트 케이스의 개수가 입력됨        
``` python 
testcase = int(input())
```


<br>


## for문을 통해 한 케이스별로 
## 1) 요소 개수, 2) 알고 싶은 요소의 위치, 3) 중요도 리스트를 입력받기
인쇄 연산(pop)을 수행할 때마다 카운트할 변수도 생성
``` python
for _ in range(testcase):
  n, m = list(map(int, input().split(' ')))
  rank = list(map(int, input().aplit(' ')))

  ct = 0
```


<br>


## 중요도와 그 위치(인덱스)를 기준으로 재구성
[중요도1, 중요도2, 중요도3, ...]으로 구성된 리스트는 인덱스로 접근하면 복잡해짐    
따라서 [(0, 중요도1), (1, 중요도2), (2, 중요도3), ...]과 같은 꼴로 만들어주기    
``` python
queue = [(idx, rank) for idx, rank in enumerate(rank)]
```


<br>


--- 

<br>


## while True를 이용하여 알고 싶은 요소가 인쇄될 때까지 코드 수행
첫 번째 요소에 가장 큰 값이 와야지 인쇄    
인쇄될 때 ct 업데이트    
첫 번째 요소에 가장 큰 값이 왔고, 그것이 알고 싶은 요소인 경우 ct를 프린트하고 종료(break)    
첫 번째 요소에 가장 큰 값이 왔지만, 알고 싶은 요소는 아닌 경우 인쇄하고 ct 업데이트    
첫 번쨰 요소에 가장 큰 값이 오지 않았을 경우, 그 첫 번째 요소를 queue의 맨 뒤에 붙이기    
``` python
while True:
  if queue[0][1]==max(queue, key=lambda x:x[1])[1]: # 중요도 리스트의 가장 첫 번째 값(인덱스 아닌 중요도)가 해당 리스트 최댓값인 경우
    ct+1

    if queue[0][0] == m: # 해당 요소의 인덱스가 알고 싶은 요소의 위치와 같을 때
                         # 즉, 해당 요소가 알고 싶은 요소일 때
      print(ct) # 인쇄한 횟수를 프린트하고 
      break # 종료

    else: # 리스트의 가장 처음에 최대 중요도를 가진 요소가 있지만, 알고 싶은 요소는 아닐 때
      queue.pop(0) # 첫 요소를 인쇄함

  else: # 리스트의 가장 처음에 가장 큰 중요도를 가진 요소가 오지 않았을 때
    queue.append(queue.pop(0)) # 첫 요소를 맨 뒷 요소로 보내버리기
```


<br>


--- 

<br>



## <span style="background-color:#fff5b1;">총정리</span>    
메모리 : 30840     
시간 : 120ms   
``` python
test_case = int(input())

for _ in range(test_case):
    n, m = list(map(int, input().split(' ')))
    rank = list(map(int, input().split(' ')))
    queue = [(idx, rank) for idx, rank in enumerate(rank)]
    ct = 0
    
    while True:
        if queue[0][1] == max(queue, key=lambda x:x[1])[1]:
            ct+=1
            if queue[0][0] == m:
                print(ct)
                break
            else:
                queue.pop(0)
        else:
            queue.append(queue.pop(0))
```

[프린터큐]: https://www.acmicpc.net/problem/1966